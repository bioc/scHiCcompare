---
title: "ScHiCcompare Vignette"
author:
- name: My Nguyen
  affiliation:
  - &1 Department of Biostatistics, Virginia Commonwealth University, Richmond, VA
- name: Mikhail Dozmorov
  affiliation:
  - *1
date: '`r format(Sys.Date(), "%B %e, %Y")`'
package: ScHiCcompare
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{ScHiCcompare}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
options(width = 1000)
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

`ScHiCcompare` is package of functions designed for the imputation, joint normalization, and detection of differential chromatin interactions between two groups of single-cell Hi-C datasets (scHi-C). [??? How such groups are created? Talk about pre-defining them by clustering, which methods] It works with processed Hi-C data, specifically chromosome-specific chromatin interaction matrices, and accepts five-column tab-separated text files in a sparse matrix format. 

<!-- What sets `ScHiCcompare` apart from other tools is its focus on processed chromatin interaction matrices rather than raw sequencing data. [??? Not important] -->The package provides two key functionalities:

-   Imputation of single-cell Hi-C data
-   Differential analysis to identify differences in chromatin interactions between groups.

# Implement [??? Too many subheaders]

## Getting Start

### Installation

```{r, message=FALSE, warning=FALSE, eval = F}
if (!requireNamespace("BiocManager", quietly=TRUE))
   install.packages("BiocManager")

BiocManager::install("ScHiCcompare") # {??? Use proper capitalization}

# For the latest version install from GitHub
# devtools::install_github("dozmorovlab/ScHiCcompare")
```

```{r,  message=FALSE, warning=FALSE, echo = F}
#devtools::install_github("dozmorovlab/ScHiCcompare", force = T)
```

```{r, message=FALSE, warning=FALSE}
library(scHiCcompare)
library(tidyr)
library(ggplot2)
library(gridExtra)
library(lattice)
```

### Input schi-c data

You will need processed Hi-C data in the form of sparse upper triangular matrices to use ScHiCcompare with 5 columns (chr1, start1, chr2, start2, IF). [??? What is IF?] ScHi-C data has different formats that are available from several sources, and two examples for downloading and extracting data are listed below [??? rewrite, redundant]. [??? Mention chromosome-specific]

If you have full Hi-C contact matrices, you can convert them to sparse upper triangular format using the `full2sparse()` function of `HiCcomapre` packge, then reformat the column to achieve the requirement input format.

#### Extracting data from .hic files

If you obtain data in the .hic format you will need to first extract the matrices that you wish to compare.

1.  Download the straw software from <https://github.com/theaidenlab/straw/wiki> and install it.
2.  Use straw to extract a Hi-C sparse upper triangular matrix. An example is below:

To extract a file scHiC.hic the raw matrix corresponding to chromosome 22 at the 500kb resolution we would use the following command within the terminal

`./straw NONE scHiC.hic  22 22 BP 500000 > scHiC.500kb.txt`

This will extract the matrix from the `.hic` file and save it to the `scHiC.500kb.txt` text file, in the sparse upper triangular matrix format. See more examples on how to use `straw` at <https://github.com/theaidenlab/straw/wiki/CPP#running>. Straw requires several inputs for the extraction of data from a `.hic` file.

`<NONE/VC/VC_SQRT/KR> <hicFile(s)> <chr1>[:x1:x2] <chr2>[:y1:y2] <BP/FRAG> <binsize>`

The first argument is the normalization method; for `ScHiCcompare`, choose `NONE` to use raw data. The second argument is the .hic file name. For intrachromosomal maps, set both chromosome numbers the same. [??? "<chr1>[:x1:x2] <chr2>[:y1:y2]" is a little confusing. chr1 is the chromosome from file 1? Or is it a list of chromosomes? What do [:x1:x2] and [:y1:y2] do? start and end within each chromosome?] Interchromosomal maps can use different chromosomes, but note that ScHiCcompare only handles intrachromosomal interactions. Choose `BP` for basepair data, and specify the bin size (e.g., 10000000 for 1MB resolution). Common bin sizes are 1MB, 500KB, 100KB, 50KB, 5KB, and 1KB. Note that most matrices with resolutions higher than 10KB (i.e., matrices with resolutions of 1KB - 10KB) are typically too sparse for analysis in `ScHiCcompare`. [??? This seems to be pretty important; I would make this bolded or repeated further up in the "Input schi-c data" as it applies to all matricies, not just `.hic` files]

From here we can import the matrix into R as you would normally for any tab-delimited file.

3.  Import the data into R `data <- read.table('scHiC.500kb.txt', header=FALSE)`
4.  Repeat these steps for all scHi-C dataset of 2 groups that you wish to compare.

#### Extracting data from .cool files

To use data in the .cool format, there are multiple ways to read these files (eg., by `cooler` on terminal, by `read_file()` function of `ScHiCcompare` package, etc). We are showing 2 examples of reading .cool files below:

-   Tools in R:

    The files can be read directly into R by `read_file()` function of `ScHiCcompare`, or `cooler2bedpe()` function of `HiCcompare`.

    The `read_file` and `cooler2bedpe` functions will return a list object in the format of BEDPE, containing two elements: "cis" - Contains the intra-chromosomal contact matrices, one per chromosome; "trans" - Contains the inter-chromosomal contact matrix.

    An example of a scHiC.cool file being imported by `read_file()` function is below. You can read about this in more detail in the [Input material](#addfunc[??? needs link]) section.

    `library(ScHiCcompare)` `cool.file <- read_files("path/to/scHiC.cool", cell_type = "NSN", position.dataset = 1, type = "cool")`

-   Tools in Terminal of Mac/Linus or Command Prompt of Window

    The `cooler` software is one of software on Terminal of Mac/Linus or Command Prompt of Window that reads .cool file <http://cooler.readthedocs.io/en/latest/index.html>. The cooler index <ftp://cooler.csail.mit.edu/coolers> contains Hi-C data for `hg19` and `mm9` from many different sources. To read these file and transfer to R, you can follow these steps:

    1.  Download and install `cooler` from <http://cooler.readthedocs.io/en/latest/index.html>
    2.  Download a `.cool` file from the cooler index <ftp://cooler.csail.mit.edu/coolers>. 3.To extract the contact matrix we use the following commands in the terminal (scHiC.cool is an example .cool file):\
        `cooler dump -- scHiC.cool > scHiC.txt`
    3.  Read in the text file as you would any tab-delimited file in R\
        dataset \<- read.table("scHiC.txt", header = FALSE)\`
    4.  Repeat step 1 - 4 for single cell data.
    5.  Transfer these contact matrices of each single cell files into R by using `cooler2sparse()` of `HiCcomapre`:

    `sparse <- cooler2sparse(hesc1000kb)`

## ScHiC table

### Overview

ScHiC table is an object gathering all scHi-C data of a group (a cell type or a condition). This object is usuable for the following analysis steps, `Pooling_RF_impute()` and `pseudo_bulkHic()` functions.

The input for the `scHiC_table()` function each single cell Hi-C data need to be processed as a sparse matrix format, which store pair-wise interaction frequencies of loci pairs. Since the full matrix of chromatin interactions is symmetric, only the upper triangular portion, including the diagonal and excluding any 0, is stored as sparse matrix format. The required sparse matrix format of each single cell Hi-C is:

-   "chr" - a chromosome of first region
-   “start1” - a start coordinate (in bp) of the first region
-   “start2” - a start coordinate (in bp) of the second region
-   "IF" - the interaction frequency between 2 two regions (IFs)

```{r}
data(MG_1)
MG_sparse <- MG_1[ ,c(1,2,4,5)] # Use column names, but they look strange in the MG_1 object
names(MG_sparse) <- c('chr' , 'start1', 'start2', 'IF')
```

```{r, echo = F}
DT::datatable(head(MG_sparse), options = list(pageLength = 6, dom = 'tip'),
              rownames = FALSE, width = 700)
```

### How to create scHiC table

#### Input material

[??? Revise this paragraph for clarity] `scHiC_table()` function can receive list of single cell Hi-C datasets in sparse matrix format described as above structure. You can input the scHi-C data of singles cells as above describe ( see more [Input schi-c data](#addfunc[??? needs link]) ), then modify them to sparse format, and gather them in `list()` object. If your datasets have format of 'txt' (sparse format) or 'cool', you can read and transform scHi-C datasets of a conditions to sparse format by using `read_files()` function to output the \`list() object.

`read_files(file.path, cell, position.dataset, type, txt.sparse.heads.position, out)` [???  It is unnecessary and confusing. See comments to the function]

-   `file.path` - The directory path where the scHiC files are stored.
-   `cell` - Cell type name (e.g., 'MG', etc).
-   `position.dataset` - File positions that you want to read from the directory.
-   `type` - The file type, either 'txt' or 'cool'.
-   `txt.sparse.heads.position` - Specified head postions (chr, start1, start2, IF) in 'txt' file.
-   `out`- Output format with options 'sparse' and 'original'. To prepare for `scHiC_table()`, you should select 'sparse'.

The `read_files()` function output a list of scHiC data in sparse format for `out` = 'sparse', where each element corresponds to a dataset from the selected files.

```{r, warning= F, message=FALSE, results='hide', eval=FALSE}
### Load data folder example saved in current working directory
load_example_MGfolder() # [??? Why not just provide .txt files? Get rid of it]
MGs.list <- read_files(file.path = "MGs_example", cell = "MG", position.dataset = c(1, 2, 3), type = "txt", txt.sparse.heads.position = c(1,2,4,5))
#[??? "Error in value[[3L]](cond) : Error reading file: NA"]
```

#### scHiC_table function

After obtaining the list of single cell Hi-C datasets in sparse matrix format, you can then use this list to generate the scHic table with the `scHiC_table()` function for the chosen chromosome. You can repeat these steps to generate scHiC tables comparing 2 conditions. [??? maybe an example of comparing conditions is needed?]

`scHiC_table(file.list, cell.type, position.dataset, select.chromosome)`

-   `file.list` - The list object where elements are processed scHi-C data file. [??? Clarify - each element of the list is a file path?]
-   `cell.type` - The cell type to use in the analysis (e.g., 'NSN', 'SN').
-   `position.dataset` - A vector of indices specifying the file positions to read from the directory. [??? I'm not sure what is meant by file positions in the directory. Does this determine the order of the files within the resulting table?]
-   `select.chromosome` - The chromosome name to be studied (e.g., 'chr1' or 'chrX').

The `scHiC_table()` function will output a table where the columns represent both the genomic loci (cell, chromosome, start1, end1) and the interaction frequencies (IF) within that single cell dataset.

```{r, message=FALSE, echo=FALSE}
## full MG list
data(MGs.list)
```

```{r, message=FALSE, results='hide'}
### Input single cell hi-c in sparse format (.txt) from a path
scHiC.table_MG = scHiC_table(file.list  = MGs.list,
                             cell.type = 'MG', 
                             position.dataset =  1:3,
                             select.chromosome = 'chr22')
```

```{r, echo=FALSE}
DT::datatable(head(scHiC.table_ODC,50), options = list(scrollX = TRUE), width = 700)
```

## Imputation

### Overview

Single cell Hi-C data tends to be more sparse due to the limitation of material at each single cell and technical challenges [??? "Due to limitations and technical challenges"], and is worse at missing more information at higher resolution [??? Clarify "worse at missing more information at higher resolution"]. Imputation is designed to mitigate these sparsity chalenges by filling in the missing data at the single-cell level.

The imputation process first segments the data into genomic distances (region2 - region1), then gathers these scHi-C distances into pool bands based on its shared similar genomic distance effect [??? Clarify] (or similar mean of IFs at each of these distance data). There are 2 pooling methods: progressive pooling and Fibonacci pooling. In progressive pooling, pools of distances are consecutively combined to form larger sets. Fibonacci pooling uses the Fibonacci sequence [??? How?] to combine distances.

Random forest imputation is applied to each pool band. During the imputation process, the function imputes all missing values (NAs) within each pool within the main distance range. For distances outside this main focus range [??? Clarify - Main distance range or focus range?], if any pool contains more than `missPerc.theshold` missing values, it triggers an alternative imputation method, filling in missing values [??? missing distances?] based on the mean for distances [??? Which distances are used for the mean?].

### How to impute scHi-C data

#### Input material

[??? Revise] To use `Pooling_RF_impute()`, we need scHiC table object created in previous section, which gather all single cells' Hi- C data of a condition ( see more [How to create scHiC table](#addfunc[??? needs link]) ).

#### Pooling_RF_impute function

After obtaining the scHiC table of [??? representing?] all single cell Hi-C dataset[??? multiple datasets?] in sparse matrix format, you can impute these cells interaction frequencies with the `Pooling_RF_impute()` function using your chosen pooling style. Note that these single cells should belong to the same cell type or condition for each chromosome. You can repeat these steps to impute scHi-C data of 2 conditions that you wish to compare. [??? Perhaps another example of comparing conditions]

`Pooling_RF_impute(scHiC.table, n.imputation, main.Distances, pool.style, ...)`

-   `scHiC.table` - the scHic table oject across single cells, created by `scHiC_table()`.
-   `n.imputation` - Number of imputations from which the final imputed interaction frequencies (IFs) will be aggregated as a mean. The default is 5.
-   `main.Distances` - The genomic distance range (in bp) you want to focus on for full random forest imputation (e.g., 1:1000000). You can select 'full' for all scHiC data imputed. The default is from 1 to 10,000,000 bp. [??? chr1 has > 240,000,000bp; expected default behavior would be 'full'?]
-   `pool.style` - The pooling technique to be used. Options are 'progressive' or 'fibonacci'. The default is 'progressive'. For high-resolution data, 'progressive' may fail due to extreme sparsity, so it's recommended to switch to 'fibonacci', though it may take longer to compute.
-  For other detail, you can look up `?Pooling_RF_impute()`
   

The function `Pooling_RF_impute()` outputs imputed interactions frequency of each single cell in form of scHiC table, where each column is the imputed interaction frequency values for each single cells [??? each single cell matrix? dataset?].

```{r, message=FALSE, warning=FALSE, results='hide'}
## Imputation 
imp.cc.table.1 <- Pooling_RF_impute(scHiC.table = scHiC.table_ODC, n.imputation = 10,
                              main.Distances = 1:10000000, pool.style = 'progressive')

```

```{r, message=FALSE, warning=FALSE, echo= F}
## Imputation 
DT::datatable(head(imp.cc.table.1,50), options = list(scrollX = TRUE), width = 700)
```

## scHiC - Pseudo bulk data

### Overview

[??? Revise paragraph, unclear] One intermediate step in the `ScHiCcompare` workflow is transforming data into pseudo-bulk matrices. The output of pseudo bulk matrices of two comparing groups is usable for next step of the implement of normalization by `HiC_loess()` of `HiCcompare` package and `scHiC_bulk_compare()` of our implement.

After the imputation of contacts within pooling groups, the data is reorganized into single-cell matrices for each cell type or condition. The imputed single-cell matrices within each group are summed to generate two pseudo-bulk matrices, one for each cell type or condition. By assuming that the interaction frequency between two loci in a single cell follows a similar distribution across all scHi-C matrices for a same cell type or condition, summing these interactions allows us to gather the maximum amount of information about each condition.

### How to create scHiC - Pseudo bulk

#### Input material

To use `Pooling_RF_impute()`, we need the scHiC table object created in the previous section, which gathers all single cells' Hi-C data of a condition [??? unclear "gathers all single cells' Hi-C data of a condition"] ( see more [How to create scHiC table](#addfunc[??? needs link]) ). You can run this step with the imputed scHi-C table (output of imputation [Pooling_RF_impute function](#addfunc[??? needs link]) ) or without imputed scHi-C table (output of the [`scHiC_table()` function](#addfunc[??? needs link])).

#### pseudo_bulkHic function

With the scHiC table, you can create pseudo bulk matrix for a cell type or other condition as shown below. You can repeat these steps to create pseudo bulk matrices of 2 conditions that you wish to compare. [??? might be helpful to show an example of 2 conditions]

`pseudo_bulkHic(scHiC.table, out)`

-   `scHiC.table` - the scHic table oject across single cells created by the `scHiC_table()` function or output of the `Pooling_RF_impute()` function
-   `out` - the output format of the pseudo bulk matrix with options 'sparse' or 'full'.

The function outputs a data frame representing the pseudo-bulk Hi-C data. If `out` is 'sparse', the output is in the format of a sparse upper triangular Hi-C matrix. If `out` is 'full', the output is in the format of a full pseudo bulk Hi-C matrix.

```{r, message=FALSE, warning=FALSE, fig.width=6, fig.height=3}
## Bulk matrix in sparse format
bulk.imp.sparse.1 = na.omit(pseudo_bulkHic(scHiC.table = imp.cc.table.1, 
                                                     out = 'sparse'))

```

## Differential Analysis

### Overview

The differential analysis step aims to detect differential chromatin interactions between single-cell Hi-C data from two cell types or conditions. This workflow involves clustering normalized log fold change of interaction frequencies at each genomic distance between two cell types or conditions into difference and non-difference clusters.

The non-difference cluster's log fold change is assumed to have a normal distribution centered around 0, identified through a Gaussian Mixture Model (GMM) cluster. The difference group consists of log fold changes belonging to other distributions clusters that deviate from the non-difference group's normal distribution. To improve the precision of difference group clustering, a control [??? log] fold change threshold `fprControl.logfc` is applied, excluding bins with low log fold change, to find meaningful differences.

In cases where the size of the differences are not large enough to form distinct distributions, these differences are likely [??? assumed?] outliers of the normal distribution, which are identified by the differential analysis of `HiCcompare`.

### How to apply differential analysis

#### Input material

To use the `scHiC_bulk_compare()` function, we need the table from the `hic_loess()` function output of `HiCcompare` package, which jointly normalize pseudo bulk data of two cell types or conditions by loess regression. You can read more detail of
[??? combine the above and below paragraphs and revise for clarity]
The function `hic_loess` of `HiCcompare` package need input of `hic.table` object, which is generated from pair of sparse upper triangular Hi-C matrices, can also be created using `create.hic.table()` function.

`create.hic.table(sparse.mat1, sparse.mat2, chr, scale, ...)`

-   `sparse.mat1` - The input for the first sparse upper triangular Hi-C matrix. This parameter uses the sparse matrix format from the pseudo-bulk scHi-C data using a specific cell type or other grouping created using the `pseudo_bulkHic()` function (see more [pseudo_bulkHic function](#addfunc[??? needs link])).

-   `sparse.mat2` - The input for the second sparse upper triangular Hi-C matrix. Similarly, this uses the sparse matrix format from the pseudo-bulk scHi-C data using another cell type or other grouping, also created using the `pseudo_bulkHic()` function (see more [pseudo_bulkHic function](#addfunc[??? needs link])).

-   `chr` - The shared chromosome name for the matrices (`sparse.mat1` and `sparse.mat2`) being entered, e.g., 'chr1' or 'chrX'.

-   `scale` - Logical. If TRUE, the interaction frequencies (IFs) of the second sparse matrix will be adjusted as follows: IF2_scaled = $IF2 / (sum(IF2) / sum(IF1))$. In our original analysis, we set `scale` to FALSE.

-   For more information, you can see `?create.hic.table()`.

The function returns a `hic.table` object that can be used to normalize with the `hic_loess()` function.

```{r, message=FALSE, warning=FALSE, fig.width=5, fig.height=3}
data("scHiC.table_MG")
data("scHiC.table_ODC")

library(HiCcompare)
## Create Pseudo Bulk matrix in sparse format
bulk.sparse.1 = na.omit(pseudo_bulkHic(scHiC.table = scHiC.table_MG, 
                                           out = 'sparse'))
bulk.sparse.2 = na.omit(pseudo_bulkHic(scHiC.table = scHiC.table_ODC,
                                           out = 'sparse'))
bulk.hic.table = create.hic.table(bulk.sparse.1, bulk.sparse.2, 
                                    chr ='chr22', scale = F)
```

```{r, echo=FALSE}
DT::datatable(head(bulk.hic.table, 50), options = list(scrollX = TRUE), width = 700)
```

`hic_loess(hic.table, Plot = TRUE, Plot.smooth = FALSE, ...)`

-   `hic.table` - `hic.table` object that is created from the `create.hic.table()` function above

-   `Plot` - Logical, if the MD plot showing before/after loess normalization be output [??? Logical, output the MD plot showing before/after loess normalization, default?]

-   `Plot.smooth` - Logical, defaults to TRUE indicating the MD plot will be a smooth scatter plot. Set to FALSE for a scatter plot with discrete points. [??? Describe smoothing process a little]

-   For other detail, you can look up `?hic_loess()`

```{r, message=FALSE, warning=FALSE, fig.width=5, fig.height=3}
#jointly normalize data for a single chromosome
hic.table_normalize <- hic_loess(hic.table = bulk.hic.table, Plot = T, Plot.smooth = F)
```

#### scHiC_bulk_compare function

After obtaining the `hic.table` object showing the normalization result from the pseudo bulk matrices of two cell type groups or conditions, we can use the `scHiC_bulk_compare()` function for further differential analysis.

`scHiC_bulk_compare(norm.hic.table , D.interval, A.min, fprControl.logfc, Plot, ...)`

  - `norm.hic.table` - The `hic.table` object from the `hic_loess()` function for the pair of pseudo bulk matrices. [??? Unclear - for the pair of pseudo bulk matrices or from the pair? Does `norm.hic.table` contain the pair?]
  
  - `D.interval` - The distance intervals to consider in the analysis, or 'full' option indicating the inclusion of all genomic distances in the analysis. The distance should be scaled by dividing by the data resolution, D = (start2 - start1)/resolution (e.g., D = (16,000,000 - 17,000,000)/1,000,000 -\> D = 1). [??? What is default? 'full'?]
  
  - `A.min` - This parameter represents the quantile cutoff level used to filter low-expression interaction frequency (IF) bins during differential outlier detection in the `hic_compare()` function. Specifically, log fold change values associated with average expression levels (A, the mean of IF1 and IF2) below the specified `A.min` quantile are excluded from the analysis. You can specify the quantile level (e.g., 0.1, 0.2) as a numeric value between 0 and 1. You can also use `best_A()` function to identify best A level that maximizes the test performance.
  
  - `fprControl.logfc` - The value controlling the false positive rate by setting the threshold for the log fold change of differences. Detected differences should have a value larger than this threshold. Default is 0.8.
  
  -   For other detail, you can look up `?scHiC_bulk_compare()`

```{r, message=FALSE, warning=FALSE, fig.width=5, fig.height=3}
A = best_A(hic.table = hic.table_normalize, numChanges = 20)
## Find differences
hic.table.result <- scHiC_bulk_compare(norm.hic.table = hic.table_normalize, D.interval = 'full', A.min = A,
                                    fprControl.logfc = 0.8, Plot = T)
```

## Other functions

There are several other functions included in `ScHiCcompare`. 

`plot_imputation_heatmap()` produces a heatmap visualization for HiC and scHiC matrices. It requires an input as a sparse matrix. More information can be found in its help document and the example below [Pseudo Bulk](#addfunc[??? needs link]).

```{r}
plot.df = ODCs.list[[1]][,-1]
plot_imputation_heatmap(plot.df, main = 'scHiC matrix of a ODC cell')
```


`plot_imputed_distance_diagnostic()` produces a visualization for imputation diagnostic at each genomic distsnce. It compare the distribution of a given distance data before and after imputation. It requires input of scHiC table of the original and imputed scHiC datasets. More information can be found in its help document and the example below [Imputation](#addfunc[??? needs link]).

```{r}
plot_imputed_distance_diagnostic(org_sc_data = imp.cc.table.1, imp_sc_data = scHiC.table_ODC, D = 1)
```

# Example of scHiCompare workflow

Here is an example workflow using 50 scHiC human brain datasets (Lee et al., 2019) with ODC and MG cell types at chromosome 20 with a 1MB resolution.

#### Create ScHiC table

```{r}
## Load and create folder for example data
data(ODCs.list)
data(MGs.list)

## Create ScHiC table
scHiC.table_ODC = scHiC_table(file.list = ODCs.list, 
                              cell.type = 'ODC',
                              position.dataset =  1:50,
                              select.chromosome = 'chr22')
scHiC.table_MG = scHiC_table(file.list = MGs.list, 
                              cell.type = 'MG',
                              position.dataset =  1:50,
                              select.chromosome = 'chr22')

```

#### Imputation

In this example, we focus on imputing genomic distances from 1 to 10,000,000 (bp) with 10 times multiple imputation [??? 10 fold imputation?]. We select the progressive pooling method to create pool bands for the random forest imputation.

```{r, message=FALSE, warning=FALSE}
## Imputation with 'progressive' pooling
imp.cc.table.1 <- Pooling_RF_impute(scHiC.table = scHiC.table_ODC, n.imputation = 10,
                              main.Distances = 1:10000000, pool.style = 'progressive')
imp.cc.table.2 <- Pooling_RF_impute(scHiC.table = scHiC.table_MG, n.imputation = 10,
                              main.Distances = 1:10000000, pool.style = 'progressive')
```
[??? What is the "Diagnostic Density for imputed D = 1"? Further explaination on plots may be needed here.]
```{r, message=FALSE, warning=FALSE}
# plot imputed Distance Diagnostic
plot1 = plot_imputed_distance_diagnostic(org_sc_data = scHiC.table_ODC, imp_sc_data = imp.cc.table.1, D = 1)
plot2 = plot_imputed_distance_diagnostic(org_sc_data = scHiC.table_ODC, imp_sc_data = imp.cc.table.1, D = 2)
plot3 = plot_imputed_distance_diagnostic(org_sc_data = scHiC.table_ODC, imp_sc_data = imp.cc.table.1, D = 3)
plot4 =plot_imputed_distance_diagnostic(org_sc_data = scHiC.table_ODC, imp_sc_data = imp.cc.table.1, D = 4)
grid.arrange(plot1, plot2, plot3, plot4, ncol = 2, nrow =2)
```



#### Pseudo Bulk
[??? Further explaination on plots may be needed here.]
```{r, message=FALSE, warning=FALSE, fig.width=6, fig.height=3}
## Bulk matrix in sparse format
bulk.imp.sparse.1 = na.omit(pseudo_bulkHic(scHiC.table = imp.cc.table.1, 
                                           out = 'sparse'))
bulk.imp.sparse.2 = na.omit(pseudo_bulkHic(scHiC.table = imp.cc.table.2,
                                           out = 'sparse'))
```

```{r, message=FALSE, warning=FALSE}
## Pseudo Bulk at main Distain 1:1,000,000

bulk.org.sparse.1 = pseudo_bulkHic(scHiC.table =scHiC.table_ODC, out = 'sparse')

## plot heatmap of pseudobulk

plot1 = plot_imputation_heatmap(scHiC.sparse = bulk.org.sparse.1, main = 'Before imputation',  zlim = c(0, 15))
plot2 = plot_imputation_heatmap(scHiC.sparse = bulk.imp.sparse.1, main = 'After imputation',  zlim = c(0, 15))
grid.arrange(plot1, plot2, ncol = 2, name = 'arrange')

```

#### Loess Normalization
[??? Further explaination on plots may be needed here.]
```{r, warning=FALSE, message=FALSE}
## Jointly normalize data for a single chromosome by Loess HiCcompare
library(HiCcompare)
# create the `hic.table` object
bulk.hic.table <- create.hic.table(bulk.imp.sparse.1, bulk.imp.sparse.2, chr = 'chr22', scale = F)
#jointly normalize data for a single chromosome
hic.table_normalize <- hic_loess(bulk.hic.table, Plot = T, Plot.smooth = T)
```

#### Differential Analysis
[??? Further explaination on plots may be needed here.]
```{r, warning=FALSE, message=FALSE}
hic.table.result <- scHiC_bulk_compare(norm.hic.table = hic.table_normalize, D.interval = 1:10,
                                    fprControl.logfc = 0.5, Plot = T)
```

# Session Info

```{r, echo=FALSE}
sessionInfo()
```
